#!/usr/bin/env bash
# pgclone: prepares a PostgreSQL physical replica by syncing from primary
# REQUIREMENT: Only supports physical replication, PostgreSQL 15+
# NOTE: Replication slot is NOT used for pg_receivewal

set -euo pipefail

PGCLONE_VERSION="0.1.0"

# ==== Default parameters ====
PGPORT=5432
REPLICA_WALDIR=""
TEMP_WALDIR=""
PARALLEL=4
VERBOSE=0
RSYNC_PORT=8873

# ==== Global state ====
PG_RECEIVEWAL_PID=""
PG_RECEIVEWAL_WATCHDOG_PID=""
CLEANUP_DONE=0
RSYNC_SECRET=""
RSYNCD_SSH_PID=""
RSYNCD_WATCHDOG_PID=""
WATCHDOG_PID=""
PART_PREFIX=""
FILELIST_RAW=""
FILELIST_SORTED=""
RSYNC_LOGFILES=()

# ==== Logging ====
log() { [[ "$VERBOSE" == "1" ]] && echo "[$(date '+%F %T')] [pgclone] $*" >&2; return 0; }
err() { echo "[$(date '+%F %T')] FATAL: $*" >&2; }
fatal() { err "$@"; exit 1; }

# ==== Cleanup ====
# shellcheck disable=SC2317
cleanup() {
    rc=$?
    [[ "$CLEANUP_DONE" == "1" ]] && exit "$rc"
    CLEANUP_DONE=1
    log "Running cleanup (rc=$rc)..."

    # Stop pg_receivewal
    if [[ -n "${PG_RECEIVEWAL_PID:-}" ]]; then
        log "Killing pg_receivewal PID=$PG_RECEIVEWAL_PID"
        kill "$PG_RECEIVEWAL_PID" 2>/dev/null || true
        wait "$PG_RECEIVEWAL_PID" 2>/dev/null || true
    fi

    # Stop pg_receivewal watchdog
    if [[ -n "${PG_RECEIVEWAL_WATCHDOG_PID:-}" ]]; then
        kill "$PG_RECEIVEWAL_WATCHDOG_PID" 2>/dev/null || true
        wait "$PG_RECEIVEWAL_WATCHDOG_PID" 2>/dev/null || true
    fi

    # Stop rsyncd on master via ssh PID
    if [[ -n "${RSYNCD_SSH_PID:-}" ]]; then
        log "Stopping rsyncd (via SSH PID=$RSYNCD_SSH_PID)..."
        kill "$RSYNCD_SSH_PID" 2>/dev/null || true
        wait "$RSYNCD_SSH_PID" 2>/dev/null || true
    fi

    # Stop rsyncd watchdog
    if [[ -n "${RSYNCD_WATCHDOG_PID:-}" ]]; then
        kill "$RSYNCD_WATCHDOG_PID" 2>/dev/null || true
        wait "$RSYNCD_WATCHDOG_PID" 2>/dev/null || true
    fi

    # Stop watchdog
    if [[ -n "${WATCHDOG_PID:-}" ]]; then
        kill "$WATCHDOG_PID" 2>/dev/null || true
        wait "$WATCHDOG_PID" 2>/dev/null || true
    fi

    # Cleanup temp files created for --files-from
    [[ -n "${FILELIST_RAW:-}" && -f "$FILELIST_RAW"    ]] && rm -f "$FILELIST_RAW"
    [[ -n "${FILELIST_SORTED:-}" && -f "$FILELIST_SORTED"    ]] && rm -f "$FILELIST_SORTED"
    [[ -n "${PART_PREFIX:-}" ]] && { rm -f "${PART_PREFIX}"* 2>/dev/null || true; }

    # Cleanup rsync worker logfiles
    for f in "${RSYNC_LOGFILES[@]}"; do
        [[ -f "$f" ]] && rm -f "$f"
    done

    # Removing temp WAL dir
    if [[ -d "${TEMP_WALDIR:-}" && "$TEMP_WALDIR" == /tmp/pgclone_temp.* ]]; then
        log "Removing temp WAL dir $TEMP_WALDIR"
        rm -rf "$TEMP_WALDIR"
    fi

    # Cleanup lock if exists
    if [[ -n "${LOCK_FILE:-}" && -f "$LOCK_FILE" ]]; then
        # Delete the lock file only if we still hold its file descriptor 
        # (i.e., the file descriptor is still open).
        if flock -n 200; then
            rm -f "$LOCK_FILE"
        fi
    fi

    exit "$rc"
}
trap cleanup EXIT INT TERM

# ==== Helpers ====
validate_lsn_format() {
    [[ "$1" =~ ^[0-9A-F]+/[0-9A-F]+$ ]] || fatal "Invalid LSN format: $1"
}

validate_ssh_key() {
    local key="$1"
    [[ -f "$key" && -r "$key" ]] || fatal "SSH key missing or unreadable: $key"
}

estimate_primary_size_mb() {
    log "Estimating primary data size..."
    local kb
    kb=$(ssh -i "$SSH_KEY" -o BatchMode=yes -o StrictHostKeyChecking=no "$SSH_USER@$PGHOST" "du -sk '$PRIMARY_PGDATA'" | awk '{print $1}')
    [[ "$kb" =~ ^[0-9]+$ ]] || fatal "du failed on primary"
    echo $((kb / 1024))
}

check_replica_disk_space() {
    local dir="$1"
    local required="$2"
    local avail_kb
    avail_kb=$(df -k "$dir" | awk 'NR==2 {print $4}')
    local avail_mb=$((avail_kb / 1024))
    [[ "$avail_mb" -lt "$required" ]] && fatal "Insufficient disk space: ${avail_mb}MB < ${required}MB"
    log "Disk OK in $dir: ${avail_mb}MB free (need $required)"
}


### MAIN SCRIPT STARTS HERE ###

# ==== Parse arguments ====
while [[ $# -gt 0 ]]; do
    case "$1" in
        --pghost) PGHOST="$2"; shift 2 ;;
        --pgport) PGPORT="$2"; shift 2 ;;
        --pguser) PGUSER="$2"; shift 2 ;;
        --primary-pgdata) PRIMARY_PGDATA="$2"; shift 2 ;;
        --replica-pgdata) REPLICA_PGDATA="$2"; shift 2 ;;
        --replica-waldir) REPLICA_WALDIR="$2"; shift 2 ;;
        --ssh-key) SSH_KEY="$2"; shift 2 ;;
        --ssh-user) SSH_USER="$2"; shift 2 ;;
        --temp-waldir) TEMP_WALDIR="$2"; shift 2 ;;
        --parallel) PARALLEL="$2"; shift 2 ;;
        --rsync-port) RSYNC_PORT="$2"; shift 2 ;;
        --verbose) VERBOSE=1; shift ;;
        -v|--version)
            echo "pgclone version $PGCLONE_VERSION"
            exit 0
            ;;
        -h|--help)
            echo "Usage: $0 [OPTIONS] ..."
            echo "  --pghost           Primary host"
            echo "  --pgport           Primary port"
            echo "  --pguser           Primary user"
            echo "  --primary-pgdata   Primary PGDATA path"
            echo "  --replica-pgdata   Replica PGDATA path"
            echo "  --replica-waldir   Replica pg_wal path"
            echo "  --ssh-key          SSH private key file"
            echo "  --ssh-user         SSH user"
            echo "  --temp-waldir      Temp WAL dir"
            echo "  --parallel         Number of parallel rsync jobs"
            echo "  --rsync-port       Rsync port"
            echo "  --verbose          Verbose output"
            echo "  -V, --version      Print version and exit"
            echo "  -h, --help         Show this help and exit"
            exit 0
            ;;
        *) fatal "Unknown arg: $1" ;;
    esac
done

# Logging script version
log "pgclone script version $PGCLONE_VERSION"

# ==== Validate ====
: "${PGHOST:?--pghost required}"
: "${PGUSER:?--pguser required}"
: "${PRIMARY_PGDATA:?--primary-pgdata required}"
: "${REPLICA_PGDATA:?--replica-pgdata required}"
: "${SSH_KEY:?--ssh-key required}"
: "${SSH_USER:?--ssh-user required}"
[[ -z "${PGPASSWORD:-}" ]] && fatal "PGPASSWORD env variable is required"
[[ "$PGPORT"    =~ ^[0-9]+$ ]] || fatal "Invalid port"
[[ "$PARALLEL"  =~ ^[0-9]+$ ]] || fatal "Invalid parallel"

TEMP_WALDIR="${TEMP_WALDIR:-$(mktemp -d -t pgclone_temp.XXXX)}"
REPLICA_WALDIR="${REPLICA_WALDIR:-$REPLICA_PGDATA/pg_wal}"

validate_ssh_key "$SSH_KEY"
mkdir -p "$REPLICA_PGDATA" "$REPLICA_WALDIR" "$TEMP_WALDIR"

# ==== Check tools ====
for t in ssh psql pg_receivewal rsync find du split awk sha256sum od; do
    command -v "$t" >/dev/null || fatal "$t not found"
done

# ==== Protect against concurrent runs of pgclone for the same replica data directory. ====
# The lock is automatically released when the script exits.
REPLICA_PGDATA_ABS=$(readlink -f "$REPLICA_PGDATA")
LOCK_FILE="/tmp/pgclone_$(echo -n "$REPLICA_PGDATA_ABS" | sha256sum | cut -d' ' -f1).lock"
exec 200>"$LOCK_FILE"
flock -n 200 || fatal "Another pgclone is running for $REPLICA_PGDATA_ABS (lock: $LOCK_FILE)"

# ==== Check SSH connection ====
ssh -i "$SSH_KEY" -o BatchMode=yes -o StrictHostKeyChecking=no "$SSH_USER@$PGHOST" "echo OK" >/dev/null ||
    fatal "SSH test failed"

# ==== Disk space check ====
primary_size=$(estimate_primary_size_mb)
required_space=$((primary_size * 1))
check_replica_disk_space "$REPLICA_PGDATA" "$required_space"

# ==== Open persistent psql session ====
log "Open persistent psql session..."
PSQL_IN=$(mktemp -u)
PSQL_OUT=$(mktemp -u)
mkfifo "$PSQL_IN" "$PSQL_OUT"

PGPASSWORD="$PGPASSWORD" psql -h "$PGHOST" -p "$PGPORT" -U "$PGUSER" -w -X -A -t <"$PSQL_IN" >"$PSQL_OUT" &
PSQL_PID=$!
exec 3>"$PSQL_IN"
psql_send() { echo "$1" >&3; }
psql_wait() { grep -m 1 . <"$PSQL_OUT"; }

# ==== PostgreSQL version ====
psql_send "SHOW server_version_num;"
ver=$(psql_wait | tr -d '[:space:]')
[[ -z "$ver" ]] && fatal "Could not retrieve PostgreSQL version"
[[ "$ver" -ge 150000 ]] || fatal "PostgreSQL >= 15 required"

# ==== Start pg_receivewal (no slot) ====
PG_RCV_APPNAME="pgclone-$$"      # unique application_name for this run
log "Starting pg_receivewal (appname=$PG_RCV_APPNAME, no slot)..."
if [[ "$VERBOSE" == "1" ]]; then
    pg_rwal_args+=(--verbose)
else
    pg_rwal_args+=()
fi
PGAPPNAME="$PG_RCV_APPNAME" pg_receivewal \
    --host="$PGHOST" --port="$PGPORT" --username="$PGUSER" \
    --no-password --directory="$TEMP_WALDIR" \
    "${pg_rwal_args[@]}" >"$TEMP_WALDIR/pg_receivewal.log" 2>&1 &
PG_RECEIVEWAL_PID=$!
sleep 3
kill -0 "$PG_RECEIVEWAL_PID" 2>/dev/null || fatal "pg_receivewal failed"

# ==== Watchdog for pg_receivewal ====
(
    main_pid=$$
    while kill -0 "$main_pid" 2>/dev/null; do sleep 1; done
    log "[watchdog] Main process $main_pid died, killing pg_receivewal PID $PG_RECEIVEWAL_PID"
    kill "$PG_RECEIVEWAL_PID" 2>/dev/null
) &
PG_RECEIVEWAL_WATCHDOG_PID=$!

# Wait until the walreceiver connection shows up in pg_stat_replication
wait_for_replication_start() {
    local appname t0 timeout
    appname="$1" 
    timeout="${2:-60}"
    t0=$(date +%s)
    log "Waiting for WAL stream to appear in pg_stat_replication (timeout=${timeout}s)..."
    while (( $(date +%s) - t0 < timeout )); do
        # Ensure pg_receivewal is still alive
        kill -0 "$PG_RECEIVEWAL_PID" 2>/dev/null \
            || fatal "pg_receivewal exited"

        # Check pg_stat_replication for our application_name
        psql_send "SELECT 1 FROM pg_stat_replication WHERE application_name='$appname' LIMIT 1;"
        if [[ $(psql_wait | tr -d '[:space:]') == "1" ]]; then
            log "WAL streaming is active, continuing..."
            return 0
        fi
        sleep 1
    done
    fatal "Timeout ${timeout}s: WAL streaming did not start"
}

wait_for_replication_start "$PG_RCV_APPNAME"

# ==== Backup start ====
psql_send "SELECT * FROM pg_backup_start('pgclone', true);"
START_LSN=$(psql_wait | awk -F '|' '{print $1}' | tr -d '[:space:]')
validate_lsn_format "$START_LSN"
log "Backup start LSN: $START_LSN"

# ==== Parallel rsync sync (rsyncd + watchdog on replica) ====
log "Setting up parallel rsync with rsyncd on master..."

RSYNC_SECRET=$(head -c 12 /dev/urandom | od -An -tx1 | tr -d ' \n')
RSYNC_SECRET_FILE=$(mktemp)
echo "$RSYNC_SECRET" > "$RSYNC_SECRET_FILE"
chmod 600 "$RSYNC_SECRET_FILE"

RSYNCD_CONF=$(cat <<EOF
uid = postgres
gid = postgres
use chroot = no
max connections = $PARALLEL
port = $RSYNC_PORT
pid file = /tmp/rsyncd.pid
log file = /tmp/rsyncd.log
[pgdata]
    path = $PRIMARY_PGDATA
    comment = PostgreSQL data
    read only = yes
    auth users = replica
    secrets file = /tmp/rsyncd.secrets
EOF
)

ssh -i "$SSH_KEY" -o BatchMode=yes -o StrictHostKeyChecking=no "$SSH_USER@$PGHOST" "echo '$RSYNCD_CONF' > /tmp/rsyncd.conf"
ssh -i "$SSH_KEY" -o BatchMode=yes -o StrictHostKeyChecking=no "$SSH_USER@$PGHOST" "echo 'replica:$RSYNC_SECRET' > /tmp/rsyncd.secrets && chmod 600 /tmp/rsyncd.secrets"

log "Starting rsyncd daemon on master via SSH..."
ssh -tt -i "$SSH_KEY" -o BatchMode=yes -o StrictHostKeyChecking=no "$SSH_USER@$PGHOST" \
    "bash -c '
        trap '\''echo \$rsyncd_pid > /tmp/rsyncd.test; kill -9 \$rsyncd_pid; wait \$rsyncd_pid; rm -f /tmp/rsyncd*; '\'' SIGHUP INT TERM
        rsync --daemon --no-detach --config=/tmp/rsyncd.conf --port=$RSYNC_PORT &
        rsyncd_pid=\$!
        wait
    '" 2>&1 &
RSYNCD_SSH_PID=$!

# Watchdog: if main process dies, kill ssh (which stops rsyncd)
(
    main_pid=$$
    while kill -0 "$main_pid" 2>/dev/null; do sleep 1; done
    log "[watchdog] Main process $main_pid died, killing rsyncd SSH PID $RSYNCD_SSH_PID"
    kill "$RSYNCD_SSH_PID" 2>/dev/null
) &
RSYNCD_WATCHDOG_PID=$!

sleep 2

# Setup rsync log arguments
rsync_log_args=()
[[ "$VERBOSE" == "1" ]] && rsync_log_args+=(--stats --human-readable)

# ==== Initial rsync of all PGDATA except pg_wal and base ====
log "Initial rsync of PGDATA (excluding base and pg_wal)..."
rsync -a --delete \
    --exclude 'pg_wal/' \
    --exclude 'base/' \
    "${rsync_log_args[@]}" \
    --password-file="$RSYNC_SECRET_FILE" \
    "rsync://replica@$PGHOST:$RSYNC_PORT/pgdata/" "$REPLICA_PGDATA/"

# Ensure empty base and pg_wal directories exist
mkdir -p "$REPLICA_PGDATA/base" "$REPLICA_PGDATA/pg_wal"

# ==== Parallel rsync of every file in base using --files-from ====
log "Building file list from primary..."

# --- Build and split the file list for balanced rsync workers ---

# 1. Gather the list of files (with their sizes in bytes) from the remote 'base' directory
# Output format: <size_in_bytes>\t<relative_path>
PART_PREFIX=$(mktemp -u -t pgclone_part.XXXXXX)
FILELIST_RAW=$(mktemp -t pgclone_files_raw.XXXXXX)
FILELIST_SORTED=$(mktemp -t pgclone_files_sorted.XXXXXX)
for ((i=0; i<PARALLEL; i++)); do
    echo > "${PART_PREFIX}_$i"
done

# Get file sizes and paths using rsync --list-only (awk extracts the size and relative path)
rsync --list-only --recursive \
      --password-file="$RSYNC_SECRET_FILE" \
      "rsync://replica@$PGHOST:$RSYNC_PORT/pgdata/base/" \
      | awk '$1 ~ /^-/ {gsub(/,/, "", $2); print $2 "\t" $5}' > "$FILELIST_RAW"

# 2. Sort all files in descending order of size (largest files first)
sort -nr "$FILELIST_RAW" > "$FILELIST_SORTED"

# 3. Distribute files among PARALLEL workers (ring-hop algorithm):
chunksize=()
for ((i=0; i<PARALLEL; i++)); do
    chunksize[i]=0
done

curr_chank=0
while IFS=$'\t' read -r sz path; do
    next_chunk=$(( (curr_chank + 1) % PARALLEL ))
    if (( chunksize[next_chunk] < chunksize[curr_chank] )); then
        curr_chank=$next_chunk
    fi
    # Assign this file to the selected chunk
    echo "$path" >> "${PART_PREFIX}_$curr_chank"
    chunksize[curr_chank]=$(( ${chunksize[$curr_chank]} + sz ))
done < "$FILELIST_SORTED"

log "Creating directory tree locally..."
awk -F'\t' '{print $2}' "$FILELIST_RAW" | awk -F/ 'NF>1{NF--; print}' OFS=/ | sort -u | while read -r d; do
    mkdir -p "$REPLICA_PGDATA/base/$d"
done

log "Running $PARALLEL rsync workers..."
pids=()

mapfile -t parts < <(ls "${PART_PREFIX}"*)
for idx in "${!parts[@]}"; do
    part="${parts[$idx]}"
    logfile=$(mktemp -t pgclone_rsync_log_"${idx}"_XXXXXX)
    RSYNC_LOGFILES+=("$logfile")
    (
        log "===== rsync worker $((idx + 1)) starting (files-from: $part) ====="
        rsync -a --relative --inplace \
              "${rsync_log_args[@]}" \
              --files-from="$part" \
              --password-file="$RSYNC_SECRET_FILE" \
              "rsync://replica@$PGHOST:$RSYNC_PORT/pgdata/base/" \
              "$REPLICA_PGDATA/base/" >"$logfile" 2>&1
        log "===== rsync worker $((idx + 1)) finished (files-from: $part) ====="
    ) &
    pids+=($!)
done
for pid in "${pids[@]}"; do
    wait "$pid"
done

for idx in "${!RSYNC_LOGFILES[@]}"; do
    if [[ -s "${RSYNC_LOGFILES[$idx]}" ]]; then
        echo
        echo "====== rsync worker $((idx + 1)) output log start ======"
        cat "${RSYNC_LOGFILES[$idx]}"
        echo "====== rsync worker $((idx + 1)) output log end ======"
        echo
    fi
    rm -f "${RSYNC_LOGFILES[$idx]}"
done

rm -f "$RSYNC_SECRET_FILE"
log "Parallel sync of base files complete"
log "Parallel rsync done"

# ==== Stop backup ====
log "Stopping backup..."
psql_send "
COPY (
  SELECT lsn,
         translate(encode(labelfile::bytea,  'base64'), E'\n', '') AS lab_b64,
         translate(encode(spcmapfile::bytea, 'base64'), E'\n', '') AS map_b64
  FROM   pg_backup_stop(true)
) TO STDOUT WITH (FORMAT text, DELIMITER '|');
"

IFS='|' read -r STOP_LSN BLABEL_B64 SPCMAP_B64 < <(psql_wait)

printf '%s' "$BLABEL_B64" | base64 --decode > "$REPLICA_PGDATA/backup_label"
[[ -n $SPCMAP_B64 ]] && printf '%s' "$SPCMAP_B64" | base64 --decode > "$REPLICA_PGDATA/tablespace_map"

# 3. Copy fresh pg_control produced by pg_backup_stop()
ssh -i "$SSH_KEY" -o BatchMode=yes -o StrictHostKeyChecking=no \
    "$SSH_USER@$PGHOST" "cat '$PRIMARY_PGDATA/global/pg_control'" \
    > "$REPLICA_PGDATA/global/pg_control"

log "Backup stopped at LSN $STOP_LSN and control files written"

log "Closing persistent psql session..."
psql_send '\q'
wait "$PSQL_PID"
rm -f "$PSQL_IN" "$PSQL_OUT"

# ==== Stop pg_receivewal ====
log "Stopping pg_receivewal..."
if kill -0 "$PG_RECEIVEWAL_PID" 2>/dev/null; then
    kill -TERM "$PG_RECEIVEWAL_PID"
    wait "$PG_RECEIVEWAL_PID" || true
fi

# ==== Move WAL files ====
log "Moving WAL to $REPLICA_WALDIR..."
find "$TEMP_WALDIR" -type f -exec mv -f {} "$REPLICA_WALDIR/" \;
rm -rf "$TEMP_WALDIR"
TEMP_WALDIR=""

log "Renaming partial WAL files..."
find "$REPLICA_WALDIR" -type f -name '*.partial' -exec bash -c 'for f; do mv "$f" "${f%.partial}"; done' _ {} +

# ==== Final checks ====
for f in PG_VERSION postgresql.conf pg_hba.conf; do
    [[ -f "$REPLICA_PGDATA/$f" ]] || fatal "Missing file: $f"
done
wal_count=$(find "$REPLICA_WALDIR" -type f -name '[0-9A-F]*' | wc -l)
[[ "$wal_count" -gt 0 ]] || fatal "No WAL files in $REPLICA_WALDIR, see pg_walreceiver log $REPLICA_WALDIR/pg_receivewal.log"
rm -f "$REPLICA_WALDIR/pg_receivewal.log"
log "Found $wal_count WAL files"

chmod 700 "$REPLICA_PGDATA" "$REPLICA_WALDIR" || log "chmod failed"

log "Replica prepared. Don't forget:"
log "  1. Create standby.signal in $REPLICA_PGDATA"
log "  2. Configure postgresql.conf with primary_conninfo"
log "  3. Start PostgreSQL"

exit 0
